load "CWIPI"
load "PETSc"
macro dimension()3// EOM
include "macro_ddm.idp"
load "medit"
load "msh3"
include "cube.idp"
string cplname = "FSI";
string cpldistname = "FreeFem++-r";
int entitiesdim = 2;
real tolgeom = 0.1;
int outfreq = 1;
string outformat = "Ensight Gold";
string outformatoption = "text";

cout << "MPI rank femscoupling1 = " << mpirank << " " << mpisize << endl;


int[int]  Nxyz=[1,1,1];
real [int,int]  Bxyz=[[0.,1.],[0.,1.],[0.,1.]];
int [int,int]  Lxyz=[[1,2],[3,4],[5,6]];
mesh3 Th=Cube(Nxyz,Bxyz,Lxyz);

int[int] BoundaryLabels = [2]; //labels used for coupling
int NbLabels = BoundaryLabels.n;
int NbBoundaryElts = Th.nbe; //Nb of Elements of all the Boundary faces
int BoundaryElts=0; // Nb of Elements of the required element faces

for (int k = 0; k < NbBoundaryElts; k++){
        for (int i = 0; i < BoundaryLabels.n; i++){
                if (Th.be(k).label == BoundaryLabels(i)){
                BoundaryElts++;
                }
        }
}

int numVertexDOF = 3;
int [int] BoundaryConnec (numVertexDOF*BoundaryElts);
int [int] temp (BoundaryElts+1);
int [int] BoundaryConnecidx (BoundaryElts+1); //Shifted Index array
int [int] UniqueID(BoundaryElts);
int order = 1; //Mesh polynomial order

//INTERLACED CONNECTIVITY MATRIX
int bcounter = 0;
for (int m = 0; m < NbBoundaryElts; m++){
        for (int i = 0; i < BoundaryLabels.n; i++){
                if (Th.be(m).label == BoundaryLabels[i]){
                    for( int k=0; k < numVertexDOF; ++k ) {
                        BoundaryConnec [  numVertexDOF*bcounter + k] = Th.be(m)[k];
                    }
                    bcounter++;
                }
        }
}

//cout << " BoundaryConnec: " << BoundaryConnec << endl;

for( int i =0; i < BoundaryElts; ++i ) {
 BoundaryConnecidx[i + 1] = BoundaryConnecidx[i] + 3;
}

GetUniqueConnectivity(UniqueID, BoundaryConnecidx, BoundaryConnec);

real [int] Coordinates (numVertexDOF*UniqueID.n);
for (int m=0; m < UniqueID.n; m++){
        Coordinates [numVertexDOF*m] = Th(UniqueID[m]).x  ;
        Coordinates [numVertexDOF*m+1] = Th(UniqueID[m]).y ;
        Coordinates [numVertexDOF*m+2] = Th(UniqueID[m]).z ;
}

int nnodecpl = UniqueID.n;
int nncellcpl = bcounter;

cout  << "unique ID: " << nnodecpl << endl;
cout << " BNDIndex: " << BoundaryConnecidx << endl;
cout << " coordinates: " << Coordinates << endl;
cout << " BoundaryConnec: " << BoundaryConnec << endl;
cout << "bcounter: " << nncellcpl << endl;
cout << "BoundaryElts: " << BoundaryElts << endl; 


func Pk = [P1, P1, P1]; // finite element space

mpiComm comm;
cwipiComm(comm);
macro ThComm()comm//

int nNotLocatedpoints = 0;

int sRequest=1;
int tag = 1;
int stride = 3;
int timestep = 1;
real timevalue = 0.1;
string SendValuesName = "SendArray";
real [int] SendArray (numVertexDOF*nnodecpl);
string exchangename = "Exchange";

for (int i = 0; i < numVertexDOF*nnodecpl; i++) {
    SendArray [i]   = 1.0 + i;
}
cout << "Array sent: " << SendArray << endl;
//CWIPI COUPLING AND EXCHANGE//
CwipiCreateCouplingFfpp(cplname, cpldistname, entitiesdim, tolgeom, outfreq, outformat, outformatoption);

CwipiDefineMeshFfpp(cplname, nnodecpl, nncellcpl, Coordinates, BoundaryConnecidx, BoundaryConnec);

CwipiLocateFfpp(cplname);

nNotLocatedpoints =  CwipiGetNNotLocatedPointsFfpp(cplname);

if (nNotLocatedpoints > 0) {
   cout << "---Error--- : not located points found " << nNotLocatedpoints << endl;
}

else {
   cout << "coupling nodes have been successfully located" << endl;
}


CwipiIsSendFfpp(cplname, exchangename, tag, stride, timestep, timevalue, SendValuesName, SendArray, sRequest);
CwipiWaitIsSendFfpp(cplname, sRequest);
CwipiDeleteCouplingFfpp(cplname);
